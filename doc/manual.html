<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Mother Manual</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

body {
  padding: 5px;
  margin: 10px;
  border: 2px;
  width: 80%
  background-image: none;
  background-color: #fff; /* pale dirty yellow */
  font-family: helvetica, arial, sans-serif;
  font-size: 14px;
  color: black;
}

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  border: solid thin #aaaaaa;
  background-color: #dee7ec }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="mother-manual">
<h1 class="title">Mother Manual</h1>
<div class="section">
<h1><a id="index" name="index">Index:</a></h1>
<p><strong>Configuring Mother:</strong></p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="#install-mother">Install Mother</a></li>
<li><a class="reference" href="#the-database-example-used-on-this-guide">The Database example used on this guide</a></li>
<li><a class="reference" href="#creating-a-mother-environment">Creating a Mother Environment</a>: configuring Mother for your Db</li>
</ul>
</blockquote>
<p><strong>The basic principles:</strong></p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="#simple-database-actions-i">Simple Database Actions I</a>: handling a record on a table, first way</li>
<li><a class="reference" href="#simple-database-actions-ii">Simple Database Actions II</a>: handling a record on a table, second way</li>
<li><a class="reference" href="#handling-multiple-records">Handling Multiple Records</a>: handling multiple records on a table</li>
<li><a class="reference" href="#handling-many-records">Handling Many Records</a>: faster way to handle multiple records on a table</li>
</ul>
</blockquote>
<p><strong>The introspective Mother features:</strong></p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="#handling-children">Handling Children</a></li>
<li><a class="reference" href="#handling-many-children">Handling Many Children</a>: faster way to handle children</li>
<li><a class="reference" href="#handling-relations">Handling Relations</a></li>
<li><a class="reference" href="#handling-complex-children">Handling Complex Children</a>: advanced children handling</li>
<li><a class="reference" href="#the-motherfusion-class">The MotherFusion Class</a>: handling records on different tables</li>
</ul>
</blockquote>
<p><strong>The database interface:</strong></p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="#performing-custom-queries">Performing Custom queries</a>: execute your personal queries</li>
</ul>
</blockquote>
<p><strong>Transactions, Connection Pool and Threaded Environments:</strong></p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="#transactions">Transactions</a>: how to use transactions</li>
<li><a class="reference" href="#sessions-and-threaded-environments">Sessions and Threaded Environments</a>: isolated working sessions</li>
</ul>
</blockquote>
<p><strong>Plugins:</strong></p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="#mothertrigger">MotherTrigger</a>: how to trigger DbMother classes</li>
<li><a class="reference" href="#mothercaster">MotherCaster</a>: how to check and cast fields</li>
</ul>
</blockquote>
<p><strong>Appendix:</strong></p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="#logging">Logging</a>: handling logs</li>
<li><a class="reference" href="#custom-complex-filters">Custom Complex Filters</a>: avoid SQL injection</li>
<li><a class="reference" href="#copyright-and-license">Copyright and License</a></li>
<li><a class="reference" href="#changelog-history">Changelog history</a></li>
</ul>
</blockquote>
</div>
<div class="section">
<h1><a id="install-mother" name="install-mother">Install Mother</a></h1>
<p>Pre-install requirements, one of the 2 libraries:</p>
<blockquote>
<ul class="simple">
<li>psycopg2  <a class="reference" href="http://www.initd.org/">http://www.initd.org/</a>                        { Postgres }</li>
<li>apsw      <a class="reference" href="http://initd.org/tracker/pysqlite/wiki/APSW">http://initd.org/tracker/pysqlite/wiki/APSW</a>  { SQLite }</li>
</ul>
</blockquote>
<p>Grab the DBMother tarball at:</p>
<blockquote>
<ul class="simple">
<li><a class="reference" href="http://dbmother.org/download">http://dbmother.org/download</a></li>
</ul>
</blockquote>
<p>Untar it and change directory to the created directory:</p>
<pre class="literal-block">
$ tar xzf mother-x.y.z.tgz
$ cd mother-x.y.z
</pre>
<p>To install Mother, just use distutils:</p>
<pre class="literal-block">
# python setup.py install
</pre>
<p>Be sure to run the previous command as root on Unix systems, or
to use the absolute python path on Windows if python won't be
recognized as valid command.</p>
<p>Besides the addition of the python module, a command line tool called
&quot;mothermapper&quot; will also get installed (normally in &quot;/usr/bin/&quot; and with
a man page on Unix systems).</p>
</div>
<div class="section">
<h1><a id="the-database-example-used-on-this-guide" name="the-database-example-used-on-this-guide">The Database example used on this guide</a></h1>
<p>Example code has been included with DBMother.  We use the following schema
for the sample code and our tutorial. Please pay close attention to the
following description because we will use throughout the manual.</p>
<p>Here's a graphic representation of the database:</p>
<pre class="literal-block">
   Stars
       \
        \
        Planets       Lifeforms
         /    \          /
        /      \        /
       /        \      /
Moons_info     Civiliztions
</pre>
<p>We have a need to keep track of star systems. For each star system, we have
a set of planets. For each planet we could have some information about it's
moons. Lifeforms is a table that store information about the different forms
of life present in our universe. Civilizations is a relation between Lifeforms
and Planets: we will use it to store information like, &quot;humans live on earth&quot;.</p>
<p>Here's the sql script (shipped with the tarball):</p>
<div class="important">
<p class="first admonition-title">Important</p>
<p>For Postgresql users.
For Posgtgres version &gt;= 8.1 and &lt; 8.2.3: you need to create
tables &quot;WITH OIDS&quot;. Remove &quot;WITH OIDS&quot; otherwise.</p>
<p class="last">Note that Mother is scalable and changing postgres version is
safe. If you upgrade your postgres to 8.2.3, for example, you
don't have to create tables WITH OIDS and your work environment
will be working at all.</p>
</div>
<div class="important">
<p class="first admonition-title">Important</p>
<p class="last">fields names are completely arbitrary: in particular, there is
no need for DbMother to create keys and foreign keys with the
same name.</p>
</div>
<pre class="literal-block">
create table stars (
    star_id         serial,
    star_name       text,
    star_age        int,
    star_mass       int,

    primary key(star_id)
) WHIT OIDS;

create table planets (
    star_id         int,
    planet_id       serial,
    planet_name     text,
    planet_mass     int,

    primary key(planet_id),
    foreign key(star_id) references stars(star_id)
) WITH OIDS;

create table moons_info (
    planet_id       int,
    moon_info_id    serial,
    num_moons       int,

    primary key(moon_info_id),
    foreign key(planet_id) references planets(planet_id)
) WITH OIDS;

create table lifeforms (
    life_id         serial,
    life_name       text,
    life_age        int,

    primary key(life_id)
) WITH OIDS;

create table civilizations (
    life_id         int,
    planet_id       int,
    age             int,

    foreign key(life_id) references lifeforms(life_id),
    foreign key(planet_id) references planets(planet_id)
) WITH OIDS;
</pre>
</div>
<div class="section">
<h1><a id="creating-a-mother-environment" name="creating-a-mother-environment">Creating a Mother Environment</a></h1>
<p>To handle a database with DBMother we need to create a DBMother environment,
using the <strong>mothermapper</strong> tool.
If you are ever in doubt what parameters you could use with mothermapper, try:</p>
<pre class="literal-block">
$ mothermapper -h
$ man mothermapper
</pre>
<p>Thanks to DBMother's introspection, there is no need to write XML and models
files: DBMother is able to automatically obtain the database structure.</p>
<p>First of all, we need to create a configuration file which allows one to specify:</p>
<blockquote>
<ul class="simple">
<li>database parameters</li>
<li>logging features</li>
<li>and the Connection Pool</li>
</ul>
</blockquote>
<p>To create a configuration file with default values (using Postgres as the backend),
just do:</p>
<pre class="literal-block">
$ mothermapper -P /my/path/dbmother.conf
</pre>
<p>otherwise use -S for SQLite:</p>
<pre class="literal-block">
$ mothermapper -S /my/path/dbmother.conf
</pre>
<p>At this point you need to edit the newly created map file and set the parameters
for your particular environment.  Don't worry: the conf file is heavy commented
and most options contain suitable default values.</p>
<div class="important">
<p class="first admonition-title">Important</p>
<p class="last">One value you should pay
attention to is &quot;<strong>MOTHER_MAP</strong>&quot;.  Here you should place a
reasonable directory and file name value like
&quot;/my/path/dbmother.map&quot;.</p>
</div>
<p>When you are done with your edits, test your configuration like so:</p>
<pre class="literal-block">
$ mothermapper -c /my/path/dbmother.conf -t
</pre>
<p>Now the database needs tables. Altough this is not mandatory, We can use
&quot;mothermapper&quot; to run a sql script (the sql script example is shipped with
the tarball, we assume that it was saved on /my/path/db1.sql):</p>
<pre class="literal-block">
$ mothermapper -c /my/path/dbmother.conf -e /my/path/db1.sql
</pre>
<p>Finally we need to create the DBMother map file. The map is created automatically
by &quot;mothermapper&quot;  (assuming you remembered to set the &quot;MOTHER_MAP&quot; value in the
DBMother config file) try the following:</p>
<pre class="literal-block">
$ mothermapper -c /my/path/dbmother.conf -s
</pre>
<p>Done.  If all went well you can do a final test by importing your configuration
file like so:</p>
<pre class="literal-block">
&gt;&gt;&gt; from mother.mothers import init_mother
&gt;&gt;&gt; init_mother('/my/path/dbmother.conf')
</pre>
<p>Success!!</p>
</div>
<div class="section">
<h1><a id="simple-database-actions-i" name="simple-database-actions-i">Simple Database Actions I</a></h1>
<p>In this section we will handle simple and single records. We use the persitent
connection, so make sure that the mother configuration file enables it.
Note that the faster way to execute simple db actions is explained in the
sectioin <a class="reference" href="#handling-many-records">Handling Many Records</a>. Although this way is very efficent and easy,
the DbMother classes explained in this section are more powerful, flexible and
extendible.</p>
<p>Obviously it's always possible to use both.</p>
<p>The primary concept of DbMother classes is: declare a short but extendible class
for a table: each instance of this class is a table record.
To explain this concept let's start handling records on the table 'stars'.</p>
<p>Put the following class declaration inside the file sample.py:</p>
<pre class="literal-block">
from mother.mothers import *

class ClsStars(DbMother):

    table_name= 'stars'

    def __init__(self, store= {}, flag= MO_NOA, session= None):
        DbMother.__init__(self, store, flag, session)

    def my_function(self):
        print &quot;This is my function, this is my realm&quot;
</pre>
<p>The argument <strong>session</strong> is used when dealing with the connection pool, useful for
threaded environments, as web applications. For now, forgive it. Let's take a
look at the <strong>store</strong> and the <strong>flag</strong> arguments.</p>
<p>Suppose we want to <strong>insert</strong> the Sun star on the table stars. The Sun name is 'sun',
the Sun age is 10 and the Sun mass is 20:</p>
<pre class="literal-block">
&gt;&gt;&gt; # Mother Initialization
&gt;&gt;&gt; from sample import *
&gt;&gt;&gt; init_mother('/my/conf/file')
&gt;&gt;&gt; # Working with Mother
&gt;&gt;&gt; sun_dict= {'star_name': 'sun', 'star_mass': 20, 'star_age': 10}
&gt;&gt;&gt; Sun= ClsStars(sun_dict)
&gt;&gt;&gt; Sun.insert()
&gt;&gt;&gt; print Sun
&gt;&gt;&gt; sun_id = Sun.getField('star_id')
</pre>
<p>Note that Mother has retrieved for us the primary key of Sun automatically.
Note also that Mother knows which is the primary key of the table stars.
Moreover, Mother knows the fields of that table; try to do:</p>
<pre class="literal-block">
&gt;&gt;&gt; wrong_dict= {'foo': 1}
&gt;&gt;&gt; Sun= ClsStars(wrong_dict)
&gt;&gt;&gt; Sun.insert()
</pre>
<p>A question arises: what about the initialization argument <cite>flag</cite>? This argument
is useful to perform db actions during the initialization. In other words the
Sun insertion could be made without the insert() call:</p>
<pre class="literal-block">
&gt;&gt;&gt; Sun= ClsStars(sun_dict, MO_SAVE)
</pre>
<p>The flag <strong>MO_NOA</strong> means &quot;No Action&quot; and is the default value of this argument.</p>
<p>Now we want to <strong>update</strong> the Sun record, setting the star_mass to 15:</p>
<pre class="literal-block">
&gt;&gt;&gt; Sun.setField('star_mass', 15)
&gt;&gt;&gt; # or Sun.setFields({'star_mass': 15}) to change more fields
&gt;&gt;&gt; Sun.update()
</pre>
<p>If we want to update a record without having his mother instance we have to use
his primary key (otherwise we risk a dangerous update):</p>
<pre class="literal-block">
&gt;&gt;&gt; Sun= ClsStars({'star_id': sun_id, 'star_mass': 15}, MO_UP)
</pre>
<p>Note that Mother understands automatically what has to be updated.</p>
<p>Now, we want to <strong>delete</strong> the sun record:</p>
<pre class="literal-block">
&gt;&gt;&gt; Sun.delete()
</pre>
<p>of, if we don't have a mother instance for this record, we can do:</p>
<pre class="literal-block">
&gt;&gt;&gt; ClsStars({'star_id': sun_id}, MO_DEL)
</pre>
<p>To delete a record there is no need to specify his primary key:</p>
<pre class="literal-block">
&gt;&gt;&gt; ClsStars({'star_name': 'sun'}, MO_DEL)
</pre>
<p>But note that this call will delete all records on the table stars with
star_name= 'sun'.
If you want to avoid this type of dangerous call, define your mother class
to be &quot;paranoid&quot;:</p>
<pre class="literal-block">
class ClsStars(DbMother):

    table_name= 'stars'
    paranoid = True

    def __init__(....):
        ...
</pre>
<p>Now Mother will refuse to perform db actions without a primary key.</p>
<p>Finally, we could want to <strong>select</strong> a record.</p>
<pre class="literal-block">
&gt;&gt;&gt; Sun= ClsStars({'star_id': sun_id})
&gt;&gt;&gt; Sun.load()
&gt;&gt;&gt; # or Sun.load(fields= 'star_name') if we want to load only the name
&gt;&gt;&gt; # or Sun= ClsStars({'star_id': sun_id}, MO_LOAD)
</pre>
<p>There is no need to use the primary key, but remember that this call will raise
an exception if there isn't a unique record with the specified fields (this fact
could be used to verify if a unique record with some values is present on the
database).</p>
<p>If we want to give some sql specific values to some fields, as DEFAULT, NULL,
True or False, just use <strong>SQL_DEFAULT</strong>, <strong>SQL_NULL</strong>, <strong>SQL_FALSE</strong>,
<strong>SQL_TRUE</strong>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from mother.mothers import SQL_NULL
&gt;&gt;&gt; Sun= ClsStars({'star_mass': SQL_NULL, 'star_name': 'sun'}, MO_SAVE)
&gt;&gt;&gt; print Sun
&gt;&gt;&gt; print Sun.getFields()
</pre>
<p>Note that the methods getFields() and getField() accept an optional argument:
autoload. If autoload is True, the requested fields will be retrieved from the
database if necessary.</p>
<p>All the described methods have a good inline doc:</p>
<pre class="literal-block">
&gt;&gt;&gt; print Sun.getFields.__doc__
</pre>
<p>Now, play a little bit with your classes, try to understand them.
Note that it's possible, important and encouraged to extend them, for example
redefining the __init__() method and/or adding some function:</p>
<pre class="literal-block">
class ClsStars(DbMotther):
    table_name= 'stars'

    def __init__(self, myarg, otherarg, store= {},
                 flag= MO_NOA, session= session):

        work_with_args(myarg, otherarg)
        DbMother.__init__(self, store, flag, session)

    def my_function(self, *args):
        print args
</pre>
<p>It's possible to modify and extend the Mother classes also coding some plugin.</p>
</div>
<div class="section">
<h1><a id="simple-database-actions-ii" name="simple-database-actions-ii">Simple Database Actions II</a></h1>
<p>In the previous chapter we learned how to define DbMother classes, handling
simple records. The goal of these classes is to build intelligent structures:
they are extendible with our functions and, as We will see in the next
sections, they can be extended in a very simple way to handle children and
relations with a strong introspection.</p>
<p>But We don't need always such structures: when, for example, We need only to
handle records on an isolated table, without children or relations, and without
the need to extend our Mother class with custom methods.</p>
<p>In such situations, it's possible to use a <strong>MotherFly</strong> class, whithout the
need to define a DbMother class for each table.</p>
<p>In the previous section, we defined the class ClsStars:</p>
<pre class="literal-block">
class ClsStars(DbMother):

    table_name= 'stars'

    def __init__(self, store= {}, flag= MO_NOA, session= None):
        DbMother.__init__(self, store, flag, session)
</pre>
<p>To perform the same db actions explained before, We don't need to define this
class: We can dynamically obtain it using the following methods:</p>
<blockquote>
<ul class="simple">
<li>getMotherBuilder(table_name)</li>
<li>getMotherObj(table_name [, store= {}, flag= MO_NOA, session= None])</li>
</ul>
</blockquote>
<p>For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; ClsStars= getMotherBuilder('stars')
&gt;&gt;&gt; type(ClsStars)
&gt;&gt;&gt; sun_dict= {'star_name': 'sun'}
&gt;&gt;&gt; sun= ClsStars(sun_dict, MO_SAVE)
</pre>
<p>As it's possible to see, the ClsStars is now a MotherFly instance. We can use
a MotherFly instance at the same way We use a DbMother class.
So, it's possible to perform the simple database actions explained in the
previous section without the need to define any class.</p>
<p>The getMotherObj function is simply a wrapper:</p>
<pre class="literal-block">
&gt;&gt;&gt; ClsStars= getMotherBuilder('stars')
&gt;&gt;&gt; sun= ClsStars(sun_dict, MO_SAVE)

    is eqaul to:

&gt;&gt;&gt; sun= getMotherObj('stars', sun_dict, MO_SAVE)
</pre>
<p>Although the usage of getMotherBuilder and getMotherObj is very useful and
easy, a MotherFly instance does not allow children and relations handling.
Moreover, the MotherFly instances can not be extended with our methods (not
in an easy way), or plugins and so on.</p>
<p>So, the decision to use a MotherFly class or a DbMother class depends on the
various situations. Obviously, it's always possible to use both.</p>
<p>It's higly recommended to use a MotherFly instance when We need to perform a
simple db action, because, generally, it's faster.</p>
<p>When, instead, We need to handle complex tasks, being the simple db actions
only a part of them, a DbMother class is better, because We can handle these
tasks with a Object Oriented behaviour, defining our custom methods:</p>
<pre class="literal-block">
class ClsStars(DbMother):

    table_name= 'stars'

    def __init__(self, my_arg1, my_arg2, store= {}, flag= MO_NOA, session= None)

        DbMother.__init__(self, store, flag, session)
        self.my_arg1= my_arg1
        self.my_arg2= my_arg2

    def get_arg1(self):

        return self.my_arg1

    def get_star_image(self):
        something.wget(self.my_arg2)

    ...
</pre>
</div>
<div class="section">
<h1><a id="handling-multiple-records" name="handling-multiple-records">Handling Multiple Records</a></h1>
<p>In the previous section we learned how to handle one record at time. Now we
begin to deal with a set of records. To do that a specific class is used:
<strong>MotherBox</strong>.</p>
<p>If an instance of a Mother class represents a record on a table, an instance
of a MotherBox class is a set of record of one table. Differently by DbMother,
we don't need to create a class for each table.</p>
<p>Let's start retrieving all records on the table stars:</p>
<pre class="literal-block">
&gt;&gt;&gt; from sample import *
&gt;&gt;&gt; init_mother('/my/conf/file')
&gt;&gt;&gt; star_box= MotherBox(ClsStars, filter= None, flag= MO_LOAD)
&gt;&gt;&gt; # it's also possible to use the table name instead of ClsStarts:
&gt;&gt;&gt; # star_box= MotherBox('stars', filter= None, flag= MO_LOAD)
&gt;&gt;&gt; print len(star_box)
</pre>
<p>Now the star_box instance contains the records. len(star_box) gives us the
number of retrieved records. We can choose to take them as dictionnaries or as
Mother instances:</p>
<pre class="literal-block">
&gt;&gt;&gt; mommas= star_box.getRecords(flag_obj= True)
&gt;&gt;&gt; dicts= star_box.getRecords()
&gt;&gt;&gt; for momma in mommas:
...    print momma
...
&gt;&gt;&gt; for d in dicts:
...    print d
...
</pre>
<p>When getting records as Mother instances, if a DbMother class was used to
initialize the MotherBox, instances of this class will be returned. Otherwise,
the return value is a list of MotherFly instances.</p>
<p>The MotherBox technology is more complex: a lot of args could be specified
during the initialization. First of all, the filters. Just take all records
with star_mass equal to 10:</p>
<pre class="literal-block">
&gt;&gt;&gt; star_box= MotherBox(ClsStars, filter= {'star_mass': 10}, flag= MO_LOAD)
&gt;&gt;&gt; star_box= MotherBox(ClsStars, filter= 'star_mass = 10', flag= MO_LOAD)
</pre>
<p>As you can see, fiilters could be dicts or strings. Filter could be also MoFilter
instances: this allows to escape strings, adding security. This type of
filters is explained after: for now, know that all the Mother internal operations
are safe: SQL is escaped so that SQL injection is not allowed.</p>
<p>We could be interested to retrieve only the star_name:</p>
<pre class="literal-block">
&gt;&gt;&gt; star_box= MotherBox(ClsStars, fields= ['star_name'], flag= MO_LOAD)
</pre>
<p>We could be interested to retrieve records oredered by star_id:</p>
<pre class="literal-block">
&gt;&gt;&gt; star_box= MotherBox(ClsStars, order= ['star_id'], flag= MO_LOAD)
</pre>
<p>Now that we know how to load records, it's time to see how to delete and
update them. To delete all records on stars with star_mass &gt; 15, we can do:</p>
<pre class="literal-block">
&gt;&gt;&gt; MotherBox(ClsStars, filter= 'star_mass &gt; 15', flag= MO_DEL)
</pre>
<p>To update all records on stars with star_mass = 15, setting star_age = 2, just
do:</p>
<pre class="literal-block">
&gt;&gt;&gt; fup= {'star_age': 2}
&gt;&gt;&gt; filter= {'star_mass': 15}
&gt;&gt;&gt; MotherBox(ClsStars, filter= filter, fields= fup, flag= MO_UP)
</pre>
<p>Finally, a MotherBox instance is iterable:</p>
<pre class="literal-block">
&gt;&gt;&gt; for record in MyBox:
...     print record
</pre>
</div>
<div class="section">
<h1><a id="handling-many-records" name="handling-many-records">Handling Many Records</a></h1>
<p>From Mother version &gt;= 0.6.3 a new class is available: <strong>MotherMany</strong>.
The goal of MotherMany is to speed up massive db actions
and to provide an easy way to perform db actions without
DbMother classes definition.</p>
<p>Often We don't need complex structures to execute sql statements.
A Mother class is a structured class: We can extend it with plugins, We can
handle children and relations, But sometimes, We don't need this machinery.</p>
<p>When, for example, We have an isolated table, without children and without
relations, the definition and the usage of a Mother class should be avoided.</p>
<p>The same applies when We have to perform a great number of statements: when We
need a fast approach.</p>
<p>The optimization problem is easy to understand: if You need to insert
1.000.000 of records on a table, initializing one DbMother class for each
record is crazy.</p>
<p>Altough custom queries are always available, MotherMany offers, as usual, SQL
injection controls and a fast way to execute actions.</p>
<p>The initialization of a MotherMany instance is easy:</p>
<pre class="literal-block">
&gt;&gt;&gt; MotherMany(builder, store= None, flag= MO_NOA,
...            session= None, fields= None)
</pre>
<p>The builder is a DbMother class or a table name. The store is a list of dicts,
each dict representing a record: also a simple dict is accepted. The flag, as
usual, specifies an action. The argument fields is useful when using
flag= MO_LOAD or flag= MO_UP.
The session is used when dealing with the connection Pool.</p>
<p>To insert a set of records (now using as builder a Mother class):</p>
<pre class="literal-block">
&gt;&gt;&gt; star_recors= [{'star_name': 'a'}, {'star_name': 'b'}]
&gt;&gt;&gt; MotherMany(ClsStars, star_records, MO_SAVE)
</pre>
<p>If MO_NOA is used instead of MO_SAVE, we can do the following (using as
builder a table name):</p>
<pre class="literal-block">
&gt;&gt;&gt; star_recors= [{'star_name': 'a'}, {'star_name': 'b'}]
&gt;&gt;&gt; momma= MotherMany('stars', star_records, MO_NOA)
&gt;&gt;&gt; other_records= [{'star_name': 'c'}, {'star_name': 'd'}]
&gt;&gt;&gt; other_record= {'star_name': 'e'}
&gt;&gt;&gt; momma.addRows(other_records)
&gt;&gt;&gt; momma.addRows(other_record)
&gt;&gt;&gt; momma.insert()
</pre>
<p>As You can see, addRows() accepts a list of dicts or a dict.</p>
<p>Deleting records is exactly the same: just use the MO_DEL flag or the
MotherMany.delete() call.</p>
<p>To select records, It's possible to use the argument fields, which is a list
of strings: only these fields will be loaded from the database. If the
argument fields is omitted, all the table fields will be selected:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherMany(ClsStarts, star_records, MO_LOAD)
&gt;&gt;&gt; records= momma.getRecords()
&gt;&gt;&gt; # momma= MotherMany('stars', star_records, MO_NOA)
&gt;&gt;&gt; # momma.load()
</pre>
<p>When updating records, the argument fields is used to specify which fields
have to be updated. For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; srecords= [{'star_id': 1, 'star_name': 'a'},
...            {'star_id': 2, 'star_name': 'b'}]
&gt;&gt;&gt; MotherMany('stars', srecords, MO_UP, fields= ['star_name'])
&gt;&gt;&gt; # MotherMany('stars', srecords, MO_NOA, fields= ['star_name'])
&gt;&gt;&gt; # momma.update()
</pre>
<p>will perform a set of queries like: &quot;UPDATE stars SET star_name= 'a' WHERE star_id = 1&quot;.
If the argument fields is omitted, it defaults to all the dictionnary keys
that are not part of the primary key for the table.
So, in the previous example, if fields is omitted, the result is the same.</p>
<p>Finally, it's possible to call the getRecords() method to fetch the worked
records. This method accepts an optional argument: flag_obj.
If flag_obj is False (the default), a list of dicts is returned. If flag_obj
is True, a list of Mother instances will be returned. In this case, if
MotherMany were initialized with, as builder, a Mother class, this class will
be used to initilize the instances. If the builder is a table name, the call
getRecords(flag_obj= True) returns a list of MotherFly instances.</p>
<pre class="literal-block">
&gt;&gt;&gt; dicts= momma.getRecords()
&gt;&gt;&gt; mommas= momma.getRecords(flag_obj= True)
</pre>
<p>Note that for each action, MO_LOAD excepted, the dicts returned by the
previous calls are exactly the dictionnaries used to initialize the MotherMany
class and added with addRows().
For the MO_LOAD action, instead, the results are the records fetched from the
database.</p>
<p>Remember that a MotherMany instance is iterable:</p>
<pre class="literal-block">
&gt;&gt;&gt; for record in momma:
...     print record
</pre>
</div>
<div class="section">
<h1><a id="handling-children" name="handling-children">Handling Children</a></h1>
<p>The table planets is a child of the table stars: a planet could be in a
particular star system. Now we learn how to handle children.</p>
<p>There are two ways to handle children: We can use the MotherMany way, or the
classic way. The first is more, more fast, but more poor. To begin We will
learn the second. The MotherMany way is explained in the section
<a class="reference" href="#handling-many-children">Handling Many Children</a>.</p>
<p>First of all we need to create a Mother class for the table planets: after
that we have to enable the children Manager for the ClsStars class, specifiyng
a list of children that we want to handle. Working on sample.py:</p>
<pre class="literal-block">
from mother.mothers import *

class ClsPlanets(DbMother):
    table_name= 'planets'
    def __init__(self, store= {}, flag= MO_NOA, session= None):
        DbMother.__init__(self, store, flag, session)

class ClsStars(DbMother, MotherManager):
    table_name= 'stars'
    def __init__(self, store= {}, flag= MO_NOA, session= None):
        self.initChildManager([ClsPlanets])
        DbMother.__init__(self, store, flag, session)
</pre>
<p>Note that we have subclassed the ClsStars class with <strong>MotherManager</strong> and called
the <strong>initChildManager()</strong> method to specify that we want to handle planets
children. There is no need to call initChildManager() on the __init__ method.
It's possible to call it manually, for example when We need it.</p>
<p>Children can be specified also as table names:</p>
<pre class="literal-block">
class ClsStars(DbMother, MotherManager):
    table_name= 'stars'
    def __init__(self, store= {}, flag= MO_NOA, session= None):
        self.initChildManager(['planets'])
        DbMother.__init__(self, store, flag, session)
</pre>
<p>So, which is the best way? Using table names does not require classes
definition: in this example there is no need to define ClsStars.</p>
<p>Using custom classes is more powerful, because when children will be handled,
there will be the chance to handle children with our custom classes instead of
handling them with a MotherFly class.</p>
<p>Another important point is: there is no need to specify a list of children.
If initChildManager() is called without arguments, Mother is able to
understand which children have to be handled.
In other words, if no argument is specified, children defaults to the list of
all children, specified by table names.</p>
<p>Now, let's create the Sun star and insert the planet Earth:</p>
<pre class="literal-block">
&gt;&gt;&gt; from sample import *
&gt;&gt;&gt; init_mother('/my/conf/file')
&gt;&gt;&gt; Sun= ClsStars({'star_name': 'sun'}, MO_SAVE)
&gt;&gt;&gt; Earth= Sun.insertPlanets({'planet_name': 'earth'})
&gt;&gt;&gt; print Earth
</pre>
<p>Note that:</p>
<blockquote>
<ul class="simple">
<li>the method insertPlanets() is created automatically</li>
<li>the foreign key 'star_id' was not specified and it's assigned automatically</li>
</ul>
</blockquote>
<p>Now we want all the planets living on the solar system:</p>
<pre class="literal-block">
&gt;&gt;&gt; planet_box= Sun.getMultiplePlanets()
</pre>
<p>Now all planets on the solar system with planet_mass &gt; 12, ordered by
planet_id:</p>
<pre class="literal-block">
&gt;&gt;&gt; ftr= 'planet_mass &gt; 12'
&gt;&gt;&gt; order= ['planet_id']
&gt;&gt;&gt; planet_box= Sun.getMultiplePlanets(filter= ftr, order= order)
</pre>
<p>If we are interested only on planet names, we can specify to load only this
field:</p>
<pre class="literal-block">
&gt;&gt;&gt; planet_box= Sun.getMultiplePlanets(fields= ['planet_name'])
</pre>
<p>If we want to retrieve a unique planet we can do:</p>
<pre class="literal-block">
&gt;&gt;&gt; Earth= Sun.getPlanets({'planet_name': 'earth'})
</pre>
<p>Note that this call will raise an exception if there isn't a unique record on
the table planets with planet_name = 'earth' and star_id =
Sun.getField('star_id').</p>
<p>We can use this fact to test if a unique planet exists:</p>
<pre class="literal-block">
&gt;&gt;&gt; try:
...   planet= Sun.getPlanets({'planet_name': 'earth'})
... except:
...   print &quot;No unique planet on the solar system with name earth&quot;
&gt;&gt;&gt;
</pre>
<p>Now it's time to update:</p>
<pre class="literal-block">
&gt;&gt;&gt; ftr= {'planet_name': 'earth'}
&gt;&gt;&gt; Sun.updateMultiplePlanets({'planet_mass': 42}, filter= ftr)
</pre>
<p>This call update all planets on the solar system with planet_name = 'earth',
setting planet_mass= 42.</p>
<p>Deleting children is similar:</p>
<pre class="literal-block">
&gt;&gt;&gt; Sun.deleteMultiplePlanets(&quot;planet_mass &gt; 12 &quot;)
&gt;&gt;&gt; Sun.deleteMultiplePlanets({'planet_mass': 2})
</pre>
</div>
<div class="section">
<h1><a id="handling-many-children" name="handling-many-children">Handling Many Children</a></h1>
<p>This section explains the second way to handle children. The difference
between this way and the classic way is almost the same between a DbMother
class and the MotherMany class.</p>
<p>The methods explained in this section are very, very fast, but more poor than
the methods created by initChildManager(), explained in the previous chapter.</p>
<p>Anyway, these methods should be used often for two reasons:</p>
<ul class="simple">
<li>they are very fast</li>
<li>they are enough for many situations</li>
</ul>
<p>As for initChildManager(), We can use the method <strong>initManyManager()</strong> to create
our methods automatically:</p>
<pre class="literal-block">
from mother.mothers import *

class ClsPlanets(DbMother):
    table_name= 'planets'
    def __init__(self, store= {}, flag= MO_NOA, session= None):
        DbMother.__init__(self, store, flag, session)

class ClsStars(DbMother, MotherManager):
    table_name= 'stars'
    def __init__(self, store= {}, flag= MO_NOA, session= None):
        self.initManyManager([ClsPlanets])
        DbMother.__init__(self, store, flag, session)
</pre>
<p>It's not mandatory to call initManyManager() during the initialization: it could be
called everytime We need it. Anyway, calling it creates the following methods:</p>
<ul class="simple">
<li>insertManyPlanets(dlist)</li>
<li>deleteManyPlanets(dlist)</li>
<li>loadManyPlanets(dlist [, fields= None])</li>
<li>updateManyPlanets(dlist [, fields= None])</li>
</ul>
<p>These methods are very similar to the MotherMany usage. The unique difference
is the authomatic export of the foreign key between parent and child.
For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; sun= ClsStars({'star_id': 1})
&gt;&gt;&gt; box= sun.insertManyPlanets([{'planet_name': 'earth'},
...                             {'planet_name': 'mars'}])
</pre>
<p>will produce the following queries:</p>
<pre class="literal-block">
INSERT INTO planets (planet_name, star_id) VALUES ('earth', 1);
INSERT INTO planets (planet_name, star_id) VALUES ('mars', 1);
</pre>
<p>The call returns a MotherMany instance.</p>
<p>As for initChildManager, it's possible to specify a list of table names
instead of a list of Mother classes.
Once more, there is no need to specify the list: if no argument is used
calling initManyManager, the magic methods will be created for each child.</p>
<p>Note that, as for the MotherMany class, for the SELECT and UPDATE actions We
can provide a list of fields: this repeats exactly the MotherMany behaviour.</p>
</div>
<div class="section">
<h1><a id="handling-relations" name="handling-relations">Handling Relations</a></h1>
<p>As for the children of one table we can handle relations with Mother.
Now we focus our attention on the tables Lifeforms, Planets and Civilizations.</p>
<p>A record on the Civilizations table means that a certain form of life lives on
a certein planet.</p>
<p>To handle children we need to enable the Children Manager calling
initChildManager(). To enable the relation manager we have to call
<strong>initRelationManager()</strong>.</p>
<p>Let's edit sample.py, inserting a class for the Lifeforms table:</p>
<pre class="literal-block">
from mother.mothers import *

class ClsLifeforms(DbMother):
    table_name= 'lifeforms'
    def __init__(self, store= {}, flag= MO_NOA, session= None):
        DbMother.__init__(self, store, flag, session)

class ClsPlanets(DbMother, MotherManager):
    table_name= 'planets'
    def __init__(self, store= {}, flag= MO_NOA, session= None):
        self.initRelationManager([ClsLifeforms])
        DbMother.__init__(self, store, flag, session)
</pre>
<p>Now we can start to handle lifeforms and civilization in a powerful way:</p>
<pre class="literal-block">
&gt;&gt;&gt; from sample import *
&gt;&gt;&gt; init_mother('/my/conf/file')
&gt;&gt;&gt; Mars= ClsPlanets({'planet_name': 'mars'}, MO_SAVE)
&gt;&gt;&gt; martians_dict= {'life_name': 'green_people'}
&gt;&gt;&gt; Martians= Mars.assignLifeforms(martians_dict, MO_SAVE)
</pre>
<p>What happens? The assignLifeforms method is a magic, auto-created method.
A new record is inserted on the table Lifeforms (MO_SAVE) and,
after that, a new record is inserted on the table Civilizations.
At the end, Martians is a Mother instance for the record inserted on the table
lifeforms.</p>
<p>We did two things in one: we inserted the martian Life and we assigned a
relation between the planet Mars and this form of life.
What about if the martian Life is already present?
It's simple:</p>
<pre class="literal-block">
&gt;&gt;&gt; Martians= ClsLifeforms(martian_dict, MO_SAVE)
&gt;&gt;&gt; Mars.assignLifeforms(Martians.getFields())
</pre>
<p>We can also load the related record:</p>
<pre class="literal-block">
&gt;&gt;&gt; martians_dict= {'life_id': 1}
&gt;&gt;&gt; Martians= Mars.assignLifeforms(martians_dict, MO_LOAD)
&gt;&gt;&gt; print Martians
</pre>
<p>If we want to insert some informations on the relation record, for example the
field &quot;age&quot;, which specifies that a certain form of life lives on a certain
planet from &quot;age&quot; years, we can do it:</p>
<pre class="literal-block">
&gt;&gt;&gt; Mars.assignLifeforms(martians_dict, MO_NOA, params= {'age': 12})
</pre>
<p>Dropping relation is easy too. To drop all relations between Mars and Lifeforms
with age &gt; 5:</p>
<pre class="literal-block">
&gt;&gt;&gt; Mars.dropMultipleLifeforms(filter= 'age &gt; 5')
</pre>
<p>If we want to use a filter on the table Lifeforms, we have to specify the
argument jfilter:</p>
<pre class="literal-block">
&gt;&gt;&gt; Mars.dropMultipleLifeforms(jfilter= {'life_name': 'green_people'})
</pre>
<p>These calls delete records on the table Civilizations.
Moreover, we can decide to act also on the table Lifeforms:</p>
<pre class="literal-block">
&gt;&gt;&gt; Mars.dropMultipleLifeforms(filter= 'age &gt; 5', flag= MO_DEL)
</pre>
<p>With this call we delete not only the relation records, but also the records on
the table lifeforms that live on Mars from at least 5 years.</p>
<p>Now we want all form of life thae live on Mars:</p>
<pre class="literal-block">
&gt;&gt;&gt; lifes_box= Mars.joinLifeforms()
</pre>
<p>If we are interested only about life names, we can specify this passing a list
of fields:</p>
<pre class="literal-block">
&gt;&gt;&gt; lifes_box= Mars.joinLifeforms(fields= ['life_name'])
</pre>
<p>We can filter and/or order the records:</p>
<pre class="literal-block">
&gt;&gt;&gt; filter= 'age &gt; 5'
&gt;&gt;&gt; jfilter= {'life_name': 'green_people'}
&gt;&gt;&gt; lifes_box= Mars.joinLifeforms(order= ['life_id'], filter= filter)
&gt;&gt;&gt; lifes_box= Mars.joinMultipleLifeforms(filter= filter, jfilter= jfilter)
</pre>
<p>Finally, we could be interested about the relation record between Mars and
Martions:</p>
<pre class="literal-block">
&gt;&gt;&gt; rel= Mars.paramsLifeforms(Martians)
&gt;&gt;&gt; # we can also use dicts:
&gt;&gt;&gt; martian_dict= {'life_id': Martians.getField('life_id')}
&gt;&gt;&gt; rel= Mars.paramsLifeforms(martian_dict)
</pre>
<p>We could be interested to retrive also a specific field:</p>
<pre class="literal-block">
&gt;&gt;&gt; rel= Mars.paramsLifeforms(Martians, fields= ['age'])
</pre>
<p>It's possible to retrieve a Mother class (there is no need to define the
class on sample.py):</p>
<pre class="literal-block">
&gt;&gt;&gt; momma=  Mars.paramsLifeforms(Martians, flag_obj= True)
</pre>
</div>
<div class="section">
<h1><a id="handling-complex-children" name="handling-complex-children">Handling Complex Children</a></h1>
<p>What about if we want to retrieve planets of the solar system with two moons
or planets on the solar system where humans live?</p>
<p>Mother is able to handle this type of JOIN queries in an easy and transaparent
way.</p>
<p>Let's start retreving all planets on the solar system where humans live:</p>
<pre class="literal-block">
&gt;&gt;&gt; humans_filter = {'life_id': 1}
&gt;&gt;&gt; box= Sun.getMultiplePlanets(jbuilder= ClsLifeforms, jfilter= humans_filter)
</pre>
<p>The same concept applies when dealing with Moons (it's your work to define the
class ClsMoons on sample.py):</p>
<pre class="literal-block">
&gt;&gt;&gt; moons_filter= {'num_moons': 2}
&gt;&gt;&gt; box= Sun.getMultiplePlanets(jbuilder= ClsMoonsInfo, jfilter= moons_filter)
</pre>
<p>Note that Mother is able to understand which tables have to be joined, altought
the two situations are a little bit different.</p>
<p>Obviously you can use at the same time the other arguments for the
getMultiplePlanets() method:</p>
<pre class="literal-block">
&gt;&gt;&gt; Sun.getMultiplePlanets(filter= 'planet_mass &gt; 5',
...                 jbuilder= ClsLifeforms, jfilter= humans_filter)
</pre>
</div>
<div class="section">
<h1><a id="the-motherfusion-class" name="the-motherfusion-class">The MotherFusion Class</a></h1>
<p>The MotherFusion class was introduced with mother version 0.6.2.
All the Mother classes presented just now are able to load records only
from a unique table.</p>
<p>The MotherFusion class allows to load records from two or three tables.
For example, we could be interested to load stars and planets at the
same time, performing a join between the two tables:</p>
<pre class="literal-block">
&gt;&gt;&gt; from mother.mothers import MotherFusion
&gt;&gt;&gt; momma= MohterFusion(ClsStars, ClsPlanets)
&gt;&gt;&gt; print len(momma)
&gt;&gt;&gt; momma.getRecords()
&gt;&gt;&gt; momma.getRecords(flag_obj= True)
</pre>
<p>The table 'planets' is a child of the table 'stars'. As we can expect,
the MotherFusion class is able to understand the database structure.
So we can use it for two tables linked with a relation, as for the tables
'planet' and 'lifeforms', that are linked with the table 'civilizations':</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsPlanets, ClsLifeforms)
</pre>
<p>Note that in both cases, you don't need to specify the nature of the
tables relation: Mother is able to understand it.</p>
<p>As we can expect, we can use filters as usual:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsPlanets, ClsStars, filter= 'planet_mass &gt; 12')
&gt;&gt;&gt; momma= MotherFusion(ClsPlanets, ClsStars, filter= {'star_mass': 14})
</pre>
<p>We can use also a MoFilter class to specify a complex filter.</p>
<p>We can specify also which fields we want to load; to do it, we can choose
different ways. If there is no problem for ambiguity, we can list them:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsStars, ClsPlanets, \
        fields= ['star_mass', 'planet_id'])
</pre>
<p>If there is an ambiguity problem, we can provide two dicts or two list
with a tuple:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsStars, ClsPlanets, \
        fields= ({'star_name': 'foo'}, {'planet_mass': 'bar'}))
</pre>
<p>This will produce: &quot;SELECT stars.star_nams AS foo, planet.planet_mass AS bar&quot;.
Following this case, remember that an empty dict means 'all table fields':</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MohterFusion(ClsStars, ClsPlanets, \
        fields= ({}, {'planet_mass': 'bar'}))
</pre>
<p>will produce: &quot;SELECT stars.*, planet.planet_mass as bar&quot;.
The following fields specification is also valid:</p>
<pre class="literal-block">
&gt;&gt;&gt; fields= (['star_name'], {'planet_mass': 'bar'})
&gt;&gt;&gt; fields= (['star_name', 'star_id'], {})
&gt;&gt;&gt; fields= (['star_name'], {})
</pre>
<p>Obvioulsy, we can provide a MotherSession and an order:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsLifeforms, ClsPlanets,
        session= MySession, order= ['star_name'])
</pre>
<p>If we set to True the 'distinct' argument, we will have a &quot;SELECT DISTINCT&quot;
statement:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsLifeforms, ClsPlanets, distinct= True)
</pre>
<p>If the two tables are not Father-Child (or Child-Fater) tables, we can
force the relation table to be used:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MohterFusion(ClsLifeforms, ClsPlanets, rtbl= 'civilizations')
</pre>
<p>In the same case, we could be interested to load also the records on
the relation tables (for example 'civilizations.age').
If we set params= True, MotherFusion will load all the fields on the
relation table:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsLifeforms, ClsPlanets, params= True)
</pre>
<p>We can also specify manually which field to load on the relation table:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsLifeforms, ClsPlanets, params= ['age'])
</pre>
<p>From version 0.6.3 or later, the initialization of MotherFusion accepts a new
argument, named 'side'. With this argument is possible to do a RIGHT or
LEFT join:</p>
<pre class="literal-block">
&gt;&gt;&gt; momma= MotherFusion(ClsLifeforms, ClsPlanets, side=&quot;RIGHT&quot;)
&gt;&gt;&gt; momma= MotherFusion(ClsLifeforms, ClsPlanets, side=&quot;LEFT&quot;)
</pre>
<p>Note that, whed using side, the order of the two Mother builders is important.</p>
<p>Finally, a MotherFusion instance is iterable:</p>
<pre class="literal-block">
&gt;&gt;&gt; for record in momma:
...     print record
</pre>
</div>
<div class="section">
<h1><a id="performing-custom-queries" name="performing-custom-queries">Performing Custom queries</a></h1>
<p>SQL is a rich language: we need to perform some custom queries.
Custom queris could be executed calling a set of functions. These functions
are exported almost everywhere. For example, each Mother instance will contain
these methods.</p>
<p>These functions have origin on the persistent connection (DbOne) and on each
session from the connection pool. Each session and the persistent connection
implement them.</p>
<p>The following methods are available:</p>
<blockquote>
<ul class="simple">
<li>oc_query(str, dict)</li>
<li>ov_query(str, dict)</li>
<li>or_query(str, dict)</li>
<li>mr_query(str, dict)</li>
<li>mg_query(str, list)</li>
<li>mq_query(str, list)</li>
<li>beginTrans()</li>
<li>commmit()</li>
<li>rollback()</li>
</ul>
</blockquote>
<p>These methods, if used correctly, are SQL injection safe.</p>
<p>Before to explain what these methods do, let's see some example to understand
the usage:</p>
<pre class="literal-block">
&gt;&gt;&gt; from mother.mothers import *
&gt;&gt;&gt; init_mother('/my/conf/file')
&gt;&gt;&gt; from mother.abdbda import DbOne
&gt;&gt;&gt; # All the following queris are in the same transaction:
&gt;&gt;&gt; DbOne.beginTrans()
&gt;&gt;&gt; sun= ClsStars(sun_dict, MO_SAVE)
&gt;&gt;&gt; earth= sun.insertPlanets(earth_dict)
&gt;&gt;&gt; earth.set_field('planet_name', 'Earth')
&gt;&gt;&gt; earth.update()
&gt;&gt;&gt; sun.oc_query('DELETE * FROM stars')
&gt;&gt;&gt; DbOne.oc_query('DELETE * FROM planets')
&gt;&gt;&gt; sun.commit()
</pre>
<p>As it's possible to see, when using the persistent connection, the instance or
the class from where we call these methods doesn't matter: each db statement
is executed inside the unique persistent connection, shared by all instances.</p>
<p>When using session, the behaviour is similar (note that sessions are always in
a transaction state):</p>
<pre class="literal-block">
&gt;&gt;&gt; from mother.mothers import *
&gt;&gt;&gt; init_mother('/my/conf/file')
&gt;&gt;&gt; session= MotherSession('session_example')
&gt;&gt;&gt; # All the following queris are in the same session-transaction:
&gt;&gt;&gt; sun= ClsStars(sun_dict, MO_SAVE, session= session)
&gt;&gt;&gt; sun.oc_query('DELETE * FROM stars')
&gt;&gt;&gt; earth= sun.insertPlanets(earth_dict)
&gt;&gt;&gt; earth.set_field('planet_name', 'Earth')
&gt;&gt;&gt; earth.update()
&gt;&gt;&gt; session.oc_query('DELETE * FROM planets')
&gt;&gt;&gt; session.endSession()
</pre>
<p>Now, the methods explanation.</p>
<p>The methods to handle transactions are self explanatory.
The methods <em>oc_query</em>, <em>ov_query</em>, <em>or_query</em>, <em>mr_query</em> have the same
syntax:</p>
<pre class="literal-block">
function(str, dict)
</pre>
<p>where str is something like:</p>
<pre class="literal-block">
When using Postgres:
&quot;INSERT INTO stars (star_name) VALUES (%(star_name)s)&quot;
When using SQLite:
&quot;INSERT INTO stars (star_name) VALUES (:star_name)&quot;
</pre>
<p>and dict is a dictionnary that contains the promised values:</p>
<pre class="literal-block">
sun_dict= {'star_name': 'sun'}
</pre>
<p>These methods do:</p>
<pre class="literal-block">
- oc_query -&gt; One Commit Query
   This method does not return any value, so it has to be used to
   perform db actions with no return: for example DELETE FROM...

- ov_query -&gt; One Value Query
   This method have to return a uniqe value. For example the query

     SELECT COUNT(1) from stars

   will return an integer.

   If a different number of results will be returned, an exception
   will be raised.

- or_query -&gt; One Record Query
   This method has to return a unique row: the return values is a dict,
   containing the values for each field. For example:

     SELECT star_name, star_age FROM stars WHERE stars.id = 1

   If a different number of rows will be returned, an exception will be
   raised.

- mr_query -&gt; Multiple Record Query
   This methods returns a list of dicts, each dict for each fetched row.
   For example:

     SELECT * from planets
</pre>
<p>The other methods, <em>mg_query</em> and <em>mq_query</em>, are used to execute massive
queries and behaves like the executemany() db drivers functions.
Instead of a dict as the second argument, they take a list of dicts.
These methods do:</p>
<pre class="literal-block">
- mq_query -&gt; Multiple Quiet Query
   &gt;&gt;&gt; li= [{'star_name': 'sun'}, {'star_name': 'alpha'}]
   &gt;&gt;&gt; mq_query('DELETE FROM stars WHERE star_name = %(star_name)s', li)

   Returns none.

- mg_query -&gt; Multiple Get Query
   &gt;&gt;&gt; li= [{'star_name': 'sun'}, {'star_name': 'alpha'}]
   &gt;&gt;&gt; mq_query('SELECT * FROM stars WHERE star_name = %(star_name)s', li)

   Returns a list of dicts
</pre>
</div>
<div class="section">
<h1><a id="transactions" name="transactions">Transactions</a></h1>
<p>Transactions are handled by Mother, which allows nested transactions. In this section
we deal once more with the persistent connection.</p>
<p>As for the methods to perform action queries, beginTrans(), commit() and rollback()
are DbOne methods, but they are exported to each Mother instance. Note that calling
these methods from a Mother instance or calling them from the DbOne class produces
the same effect:</p>
<pre class="literal-block">
&gt;&gt;&gt; DbOne.beginTrans()
&gt;&gt;&gt; try:
...     Sun.insert()
...     Sun.commit()
... except:
...     Sun.rollback()
&gt;&gt;&gt;
</pre>
<p>The chance to call nested transactions is very useful: if we call two times
beginTrans() we need to call two times commit() to commit our queries.
Instead, rollback could be called once (and calling rollback more times does
not produce any errror).</p>
<p>This allows the following code:</p>
<pre class="literal-block">
&gt;&gt;&gt; def foo():
&gt;&gt;&gt;   Sun.beginTrans()
...   try:
...     Sun.insert()
...     Sun.commit()
...   except:
...     Sun.rollback()
...     raise 'Foo'
&gt;&gt;&gt;
&gt;&gt;&gt; def bar():
...   DbOne.beginTrans()
...   try:
...     DbOne.oc_query(myquery)
...     foo()
...     DbOne.commit()
...   except:
...     DbOne.rollback()
...     raise 'Bar'
&gt;&gt;&gt;
&gt;&gt;&gt; bar()
</pre>
<p>The function foo() is not dangerous for his transaction: we can safely call
it from everywhere, because Mother is able to deal with nested transaction,
doing exactly what you need: calling bar(), queries will be committed only
with the last commit() statement inside bar() itself.</p>
<p>Obviously you can call directly foo(), obtaining now a classic behaviour.</p>
</div>
<div class="section">
<h1><a id="sessions-and-threaded-environments" name="sessions-and-threaded-environments">Sessions and Threaded Environments</a></h1>
<p>When we need to develop applications in a threaded environments, we need
isolated transactions. In fact the persistent connection is not enough,
because different flux of code have to behave indipendently, while the
persistent connection is shared to each Mother instance.</p>
<p>Mother implements a connection pool: editing the Mother configuration file
it's possible to tune it in a deep way. The file is strongly commented.</p>
<p>To get a session, the MotherSession() call is used; we can give a name to
each session: this is very useful for debugging purposes, but you can safely
call this function without arguments: Mother will assign a random name to your
session:</p>
<pre class="literal-block">
&gt;&gt;&gt; from mother.mothers import *
&gt;&gt;&gt; init_mother('/my/conf/file')
&gt;&gt;&gt; session= MotherSession('hello_world')
</pre>
<p>Now that a session is ready, we can begin to use it:</p>
<pre class="literal-block">
&gt;&gt;&gt; Sun= ClsStars(sun_dict, MO_SAVE, session)
&gt;&gt;&gt; earth= Sun.insertPlanets(earth_dict)
&gt;&gt;&gt; earth.setField('planet_mass', 34)
&gt;&gt;&gt; earth.update()
</pre>
<p>The db actions are now inside your session: note that this applies also to the
db actions produced by Earth, because Earth is born inside a session.</p>
<p>Sessions are always in a transaction state. To commit the queries we can call
commit() or endSession(). The endSession() call commit the transaction, and
puts the connections used just now back to the pool:</p>
<pre class="literal-block">
&gt;&gt;&gt; session.endSession()
</pre>
<p>while the commit() call commits all pending queries to the database, but
session is not closed and it's possible to continue to use it.</p>
<p>To rollback the queries inside a session we use rollback():</p>
<pre class="literal-block">
&gt;&gt;&gt; session= MotherSession('hello_world')
&gt;&gt;&gt; try:
...   Sun= ClsStars(sun_dict, MO_SAVE, session)
...   earth= Sun.insertPlanets(earth_dict)
...   earth.setField('planet_mass', 34)
...   earth.update()
... except:
...   session.rollback()
&gt;&gt;&gt;
&gt;&gt;&gt; session.endSession()
</pre>
<p>To perform custom queries inside sessions, just use the session methods or
the Mother instance methods:</p>
<pre class="literal-block">
&gt;&gt;&gt; session= MotherSession('CustomQueries')
&gt;&gt;&gt; try:
...   Sun= ClsStars(sun_dict, MO_SAVE, session)
...   Sun.oc_query('delete from planets')
...   session.or_query('select * from lifeforms where life_id = 1')
... except:
...   session.rollback()
&gt;&gt;&gt;
&gt;&gt;&gt; session.endSession()
</pre>
<p>When you develop internal methods, make sure to propagate the session:</p>
<pre class="literal-block">
&gt;&gt;&gt; class ClsFoo(DbMother):
...   table_name= 'foo'
...   def __init__(....):
...     ...
...
...   def wrong_method(self, *args):
...     ClsBar(mydict, MO_SAVE)
...
...   def correct_method(self, *args):
...     # this works also if no session was used to
...     # initialize this instance:
...     ClsBar(mydict, MO_SAVE, self.session)
...
...   def always_correct(self, *args):
...     # this query is executed inside a session
...     # if this instance was initialized with a
...     # session, with the persistent connection
...     # otherwise.
...     self.oc_query('delete from foobar')
</pre>
<p>Finally, to monitor the connection pool, use the following methods:</p>
<pre class="literal-block">
&gt;&gt;&gt; from mother.mothers import MotherPoolStatus, MotherPoolStratus
&gt;&gt;&gt; print MotherPoolStatus()
&gt;&gt;&gt; print MotherPoolStratus()
</pre>
</div>
<div class="section">
<h1><a id="mothertrigger" name="mothertrigger">MotherTrigger</a></h1>
<p>We can define some triggers to be fired before or after DbMother actions.
This feature requires the usage of the MotherTrigger class. To use it, We
have to subclass our DbMother class with it.</p>
<p>Explainig this feature with an example is the faster way.
Suppose that We want to send a mail to some God after a Lifeform extinction
from our Universe.
We can do the following:</p>
<pre class="literal-block">
from mother.mothers import *
from mother.plugins import MotherTrigger

class Lifeform(DbMother, MotherTrigger):

  table_name= 'stars'

  def __init__(self, my_god= 'Shiva&#64;Olympus.Paradise', store= {},
                   flag= MO_NOA, session= None):

      self.my_god= my_god
      self.add_trigger(MO_DEL, MO_AFTER, self.gods_alert)
      DbMother.__init__(self, store, flag, session)

  def gods_alert(self):

      my_god= self.my_god
      life_name= self.getField('life_name')
      sub= &quot;Lifeform Extinction&quot;
      body= &quot;The Lifeform %s is dead.&quot; % life_name
      sendmailto(my_god, sub, body)
</pre>
<p>Each action flag (MO_SAVE, MO_DEL, MO_UP and MO_LOAD) can be used with the
add_trigger() call. To trigger function before an action, it's possible to use
the MO_BEFORE symbol:</p>
<pre class="literal-block">
self.add_trigger(MO_DEL, MO_BEFORE, self.gods_alert)
</pre>
<div class="important">
<p class="first admonition-title">Important</p>
<p class="last">Triggers have to be setted before the DbMother.__init__() call, otherwise
they will be ignored when using an action flag during the initialization.</p>
</div>
</div>
<div class="section">
<h1><a id="mothercaster" name="mothercaster">MotherCaster</a></h1>
<p>The MotherCaster plugin has two goals:</p>
<blockquote>
<ul class="simple">
<li>Provide a validation for fields types</li>
<li>Provide a validation for required fields</li>
</ul>
</blockquote>
<p>The plugin is very useful when Mother is used with a Web Form, because it's
possible to control fields consistency (types) and fields presence (required
fields).</p>
<p>The Plugin is simple: a DbMother class has to be subcalssed with the
MotherCaster class, which is contained in mother.plugins.
After that, We need to define an internal dict.</p>
<p>Let's see an example:</p>
<pre class="literal-block">
from mother.mothers import DbMother, MO_NOA
from mother.plugins.mocaster import *

class ClsStars(DbMother, MotherCaster):

  cast_fields= {
      star_mass: int,
      star_age: int,
      star_name: str }

  # Optionally...
  required_fields= ['star_age']

  def __init__(self, d= {}, flag= MO_NOA, session= None):

      MotherCaster.__init__(self, autocast= True)
      DbMother.__init__(self, d, flag, session)
</pre>
<p>Note that:</p>
<blockquote>
<ul class="simple">
<li>cast_fields does not have to contain all fields for the table.</li>
<li>required_fields is optional and the previous consideration apply there.</li>
</ul>
</blockquote>
<p>When a ClsStars is initialized, the following happens:</p>
<blockquote>
<ul class="simple">
<li>fields are checked: if they have a wrong type, a casting is automatically
done (auotcast= True).</li>
<li>if a provided field is not present in the table stars, it's
dropped (note that this does not depend on cast_fields or required_fields
declarations).</li>
<li>Mother controls if all required_fields are provided.</li>
</ul>
</blockquote>
<p>If an error occurs, the following exception will be raised: MoWrongFields.
This is more then an exception: it has the following attributes: <strong>ifields</strong> and
<strong>mfields</strong>. Ifields is a list of invalid fields, while mfields is a list of
missing fields (they are required but absent):</p>
<pre class="literal-block">
&gt;&gt;&gt; MyDict= dict(star_name= 19, star_age= '12', not_existent_field=1)
&gt;&gt;&gt; MyStar= ClsStars(MyDict, MO_NOA)

# Here, star_name becomes '19' and star_age 12. not_existent_field
# is silently dropped.

&gt;&gt;&gt; MyDict= dict(star_name= 'sun', star_mass='www')
&gt;&gt;&gt; try:
...  MyStar= ClsStars(MyDict, MO_NOA)
... except MoWrongFields, errors:
...  print &quot;Invalid types:&quot;, errors.ifields
...  print &quot;Missing fields:&quot;, errors.mfields
&gt;&gt;&gt;
</pre>
<p>Here, star_mass is invalid because it's impossible to cast it to an
int, and star_age, which is a required field, is missing.</p>
</div>
<div class="section">
<h1><a id="logging" name="logging">Logging</a></h1>
<p>Logging, like the pool, is configurable on the Mother configuration file.
It's possbile to log to standard output, to file (with file rotation
capabilites), to mail and to syslog (this requires to enable syslog tcp
daemon, because windows does not support Unix sockets).</p>
<p>Once the logging features are tuned on the Mother configuration file, it's
possbible to begin to produces some string activity:</p>
<pre class="literal-block">
&gt;&gt;&gt; init_mother('/my/conf/file')
&gt;&gt;&gt; from mother.Speaker import RED, GREEN, YELLOW
&gt;&gt;&gt; import datetime
&gt;&gt;&gt; Sun= ClsStars()
&gt;&gt;&gt; Sun.log_info('It's %s', GREEN(datetime.datetime.today()))
&gt;&gt;&gt; Sun.log_warning('aia aia %s %s', RED(1), YELLOW('foo'))
&gt;&gt;&gt; from mother.speaker import *
&gt;&gt;&gt; Speaker.log_debug('the same methods are callable from the Speaker class')
&gt;&gt;&gt; Speaker.log_noise('Noise Noise %s', RED('noise'))
&gt;&gt;&gt; Speaker.log_insane('Insane Insane %s', RED('noise'))
&gt;&gt;&gt; Sun.log_noise('Soft Soft %s', RED('noise'))
</pre>
<p>Remember that the string are formatted in a C way: You don't have to use the
python way. Remember also to use always the <cite>%s</cite> symbol, also if You are
printing integer or floats:</p>
<pre class="literal-block">
&gt;&gt;&gt; # the python way
&gt;&gt;&gt; &quot;%s %d&quot; % ('a', 1)
&gt;&gt;&gt; # the mother way
&gt;&gt;&gt; &quot;%s %s&quot;, 'a', 1
</pre>
<p>Setting the configuration level, some of the previous logged string will be dropped.
To use a custom logging level, use log_log():</p>
<pre class="literal-block">
&gt;&gt;&gt; Speaker.log_log(23, 'hi %s %s %s', 1, 2 ,'a')
</pre>
<p>To turn off the logging feature, set the log level to 0.</p>
<p>If smtp logging is enabled, the function log_mail() will be available: using
it, You can send some logs via mail.</p>
</div>
<div class="section">
<h1><a id="custom-complex-filters" name="custom-complex-filters">Custom Complex Filters</a></h1>
<p>Sometime we have to use strings as filters. For example, to get all planets
with planet_mass &gt; 5, we must do:</p>
<pre class="literal-block">
&gt;&gt;&gt; MotherBox(ClsPlanets, filter= 'planet_mass &gt; 5', flag= MO_LOAD)
</pre>
<p>When no-string filters are provided, Mother is able to escape correctly the
various variables, but when we work with strings, we are tempted to do:</p>
<pre class="literal-block">
&gt;&gt;&gt; ftr= 'blabla %s %s' % (foo, bar)
&gt;&gt;&gt; MotherBox(ClsPlanets, filter= ftr, flag= MO_LOAD)
</pre>
<p>This is not good, because SQL injection is possible. To let Mother escapes
your string filters, you have to use a class: MoFilter.</p>
<p>It's easy, instead of:</p>
<pre class="literal-block">
&gt;&gt;&gt; filter= 'blabla %(foo)s %(bar)s' % {'foo': foo, 'bar': bar}
</pre>
<p>it's possible to do:</p>
<pre class="literal-block">
&gt;&gt;&gt; from mother.mothers import MoFilter
&gt;&gt;&gt; store= {'foo': foo, 'bar': bar}
&gt;&gt;&gt; filter= MoFilter('blabla %(foo)s %(bar)s', store= store}
&gt;&gt;&gt; # For SQLite you have to use:   'blabla :foo :bar'
</pre>
<p>Now Mother will escape for you the filter, adding the security layer vs SQL
injection.</p>
<p>Moreover, we can add different type of filter in the same class:</p>
<pre class="literal-block">
&gt;&gt;&gt; filter= MoFilter('blabla %(foo)s %(bar)s', store= store}
&gt;&gt;&gt; filter.add_filter({'age': 1})
&gt;&gt;&gt; filter.add_filter('dkafsak %(az)s', store= {'az': 5})
&gt;&gt;&gt; MotherBox(ClsPlanets, filter= filter, flag= MO_LOAD)
</pre>
<p>If You want to force a filter on a specific table, use the following argument:</p>
<pre class="literal-block">
&gt;&gt;&gt; filter= MoFilter({'my': 'filter'}, table= 'my_table)
</pre>
</div>
<div class="section">
<h1><a id="copyright-and-license" name="copyright-and-license">Copyright and License</a></h1>
<p>Copyright (c) 2006-2007 Federico Tomassini aka efphe (effetom at dbmother dot
org)
All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<blockquote>
<ul class="simple">
<li>Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the University of California, Berkeley nor the
names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ul>
</blockquote>
<p>THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</div>
<div class="section">
<h1><a id="changelog-history" name="changelog-history">Changelog History</a></h1>
<p>VERSION = 0.6.4-r4</p>
<blockquote>
<ul class="simple">
<li>Stupid Bugs on MotherMany</li>
</ul>
</blockquote>
<p>VERSION = 0.6.4-r3</p>
<blockquote>
<ul class="simple">
<li>man page installation with setup.py</li>
<li>mothermapper man page</li>
<li>adjusting log levels: sql logs only on debug</li>
</ul>
</blockquote>
<p>VERSION = 0.6.4-r2</p>
<blockquote>
<ul class="simple">
<li>Mother does not have to crash if and when
psycopg2.mogrify() crash.</li>
</ul>
</blockquote>
<p>VERSION = 0.6.4-r1</p>
<blockquote>
<ul class="simple">
<li>registering atexit functions to close connections</li>
<li>mothermapper: new option -g</li>
</ul>
</blockquote>
<p>VERSION = 0.6.4</p>
<blockquote>
<ul class="simple">
<li>DbMother._update() debugged</li>
<li>DbMother.delete() does not clean the store</li>
<li>Manual updated</li>
<li>License is applied to each source file</li>
<li>MO_ULOAD and DbMother.uload dropped</li>
<li>MotherBox.getFields() dropped</li>
<li>triggers is now a plugin, so DbMother is lighter</li>
<li>imports are now absolute</li>
<li>Manual: new section for MotherFly</li>
<li>MotherBox: debugged updateBox</li>
<li>MotherMany is now iterable</li>
<li>MotherFusion is now iterable</li>
<li>MotherBox is now iterable</li>
<li>MotherBox: dropped triggers</li>
<li>MotherBox and MotherMany accpet a table name instead of
DbMother class</li>
<li>initManyManager and initChildManager extended.
children list is not mandatory and children can
be specified by table names.</li>
<li>mothermapper uses MotherMany for -f option</li>
</ul>
</blockquote>
<p>VERSION = 0.6.3</p>
<blockquote>
<ul class="simple">
<li>Manual: introduces the new sections: copyright and changelog</li>
<li>Manual: new stylesheets</li>
<li>Manual: improved section for the Custom Queries</li>
<li>DbFly.ov_query() debugged</li>
<li>_DbMap inherits speaker methods directly (see previous change)</li>
<li>DbFly and DbOne are now handled in the same way</li>
<li>otpimization: DbMother classes are more light</li>
<li>sqlite bug: crash on empty results for get type queries</li>
<li>sqlite.py postgres.py: ifaces aligned</li>
<li>rewrited some methods on db interfaces</li>
<li>dropped the DictCursor psycopg2 feature</li>
<li>manual: corrections and new index layout</li>
<li>new MotherManager family functions: actionMany...</li>
<li>new MotherManager method: insertManyChildren</li>
<li>new class MotherMany</li>
<li>abdbda imports (and exports) multiple query methods</li>
<li>sqlite and postgres have now mq_query and mg_query</li>
<li>new method on postgres, sqlite and abdbda: multiple_query()</li>
<li>DbMother fields methods moved on _DbMap</li>
<li>MotherFusion: new __init__ arg <cite>side</cite></li>
</ul>
</blockquote>
<p>VERSION = 0.6.2-r1</p>
<blockquote>
<ul class="simple">
<li>relParams debugged: session was not exported</li>
<li>MotherFusion: fields handler improved</li>
</ul>
</blockquote>
<p>VERSION = 0.6.2</p>
<blockquote>
<ul class="simple">
<li>cleaned doc: Lifes -&gt; Lifeforms</li>
<li>DbOne was calling twice _connect()</li>
<li>Removed HeavyBug on Sqlite-Map creation</li>
<li>mothermapper -f: removed __import__, used execfile()</li>
<li>MotherFusion: it's now possible to specify jfilter</li>
<li>debugged arg_format usage</li>
<li>MotherFusion: debugged ({}, {}..) for selectWaht()</li>
<li>An interactive example for SQLite is provided</li>
<li>Examples for SQLite ans Postgres are provided</li>
<li>MotherFusion: __len__ method</li>
<li>MotherFusion: introduces distinct</li>
<li>MotherFusion: introduced order</li>
<li>MohterFusion is explained on the Manual</li>
<li><cite>mothermapper -f help</cite> prints a human readable help</li>
<li>MotherFusion is able to exclude redundant params</li>
<li>MotherFusion can load relation params</li>
<li>new class MotherFusion</li>
<li>code cleaned</li>
<li>new _DbMap._sqlFreeJoin method</li>
<li>_sqlJoin&amp;C moved from MotherManager to _DbMap class</li>
<li>mothermapper --help: deleted -C option</li>
</ul>
</blockquote>
<p>VERSION = 0.6.1</p>
<blockquote>
<ul class="simple">
<li>defconf.py -&gt; _defconf.py</li>
<li>def_pgres.py -&gt; _def_pgres.py</li>
<li>def_sqlite.py -&gt; _def_sqlite.py</li>
<li>mothermapper: removed C option, added -P and -S</li>
<li>added new modules: def_pgres and def_sqlite</li>
<li>debugging MohterManager methods</li>
</ul>
</blockquote>
<p>VERSION = 0.6.0</p>
<blockquote>
<ul class="simple">
<li>Sqlite Support</li>
<li>rewrited initalization methods</li>
<li>dbda removed: added abdbda</li>
<li>added specific db interface: postgres.py sqlite.py</li>
<li>mothermapper uses always a persistent connection</li>
<li>mothermapper meta queries reside now on the db core</li>
<li>MO_ULOAD action is now obsolete</li>
<li>no primary key is needed to load one record</li>
<li>no primary key is needed to modify db record</li>
<li>added the flag 'paranoid' to the Mother classes</li>
<li>added class filter MoFilter</li>
<li>Mother uses now MoFilter instances as internal filters</li>
<li>writed a new documentation guide</li>
<li>_sqlBuildFilter() removed from DbMother</li>
<li>mogrify() is used only for postgres</li>
<li>logs are more clear</li>
<li>controlling fields on getField()</li>
<li>tester.py: a test unit</li>
</ul>
</blockquote>
<p>VERSION = 0.5.6</p>
<blockquote>
<ul class="simple">
<li>dbg: Psygres reconnection</li>
<li>logging is more accurate</li>
<li>Mother uses only the pkeys to build filters (MO_ULOAD exception)</li>
</ul>
</blockquote>
<p>VERSION = 0.5.5</p>
<blockquote>
<ul class="simple">
<li>exceptions are handled more simply</li>
<li>mother is now able to restore a broken connection.
This is the case of a postgres restart, for example.
Note that psycopg2 is broken and this feature is not
working, depending on the psycopg2 version.</li>
<li>getChild() is now reimplemented</li>
<li>Avoid wildcard on select queries</li>
<li>DbMother.load() returns now the getFields() dict</li>
<li>fnaming function debugging</li>
<li>init_mother() tests the function fnaming when provided</li>
<li>MotherPoolStratus()</li>
<li>getField: obsolete parameter <cite>value</cite>. New paramater <cite>autoload</cite>.</li>
</ul>
</blockquote>
<p>VERSION = 0.5.4</p>
<blockquote>
<ul class="simple">
<li>new concept of <cite>calm</cite> for the pool</li>
<li>inserted controls testing sessions initializaztion</li>
<li>logs about pool are now cleaner</li>
<li>default configuration file changed</li>
<li>it's now possible, when using pool, to disable the base connection</li>
<li>implemented Pool Types: LIMITED, ELASTIC, GROWING</li>
<li>dropped sessions are now directly closed (reference leaks)</li>
<li>fixed the &quot;Session VS Persistent&quot; gap for internal transactions</li>
<li>DbMother class: three wrappers to handle transactions internally</li>
<li>new method: DbMother.getField()</li>
<li>mothermapper and symbols: no more massive DELETE (sync pattern)</li>
<li>mothermapper: no more transatctions: now MotherSession</li>
</ul>
</blockquote>
<p>VERSION = 0.5.3-r1</p>
<blockquote>
<ul class="simple">
<li>Fixed bug about colors on win32: mothermapper/set_log_color()</li>
<li>Fixed a not compliant query (fields IS NULL (VS) field= NULL)</li>
<li>Fixed a bug on MotherBox._retrieve_mothers()</li>
</ul>
</blockquote>
<p>VERSION = 0.5.3</p>
<blockquote>
<ul class="simple">
<li>Some output changed</li>
<li>Colors are always disabled on win32 systems.</li>
<li>A stupid bug fixed on _moMap</li>
</ul>
</blockquote>
<p>VERSION = 0.5.2-r1</p>
<blockquote>
<ul class="simple">
<li>Bug fixed: broken map on win32 platforms (cPickle)</li>
</ul>
</blockquote>
<p>VERSION = 0.5.2</p>
<blockquote>
<ul class="simple">
<li>It's now possible to commit() queries inside sessions.</li>
<li>new method MotherPoolStatus()</li>
<li>PsygresPool.back_home -&gt; PsygresPool.backHome</li>
<li>PsygresPool is not Speaker child</li>
<li>PsygresPoll attrs are now private _attrs</li>
<li>PsygresPool.session_number -&gt; PsygresPoll.status</li>
<li>PsygresPool remembers the orphaned sessions</li>
<li>PsygresPool has now a detailed method: status()</li>
<li>introduced a new argument on relParams(): flag_obj</li>
</ul>
</blockquote>
<p>VERSION = 0.5.1</p>
<blockquote>
<ul class="simple">
<li>offensive logs removed</li>
<li>the map dicts are now copied when Mother reads them</li>
<li>log_rotate debugged</li>
<li>The Mother Map is saved as pickled dict</li>
<li>Various optimizations on code</li>
<li>MotherMapped family functions dropped</li>
<li>The DB map is loaded by init_mother(), once</li>
<li>init_dbda() bug fixed (DB_PORT when using Unix sockets)</li>
<li>assignRelation debugged</li>
<li>symbols on MotherMap removed (optimization)</li>
<li>initRelationManager builds the relParams() wrapper</li>
<li>new method on Mothermanager: relParams()</li>
<li>debugged getChildren (when jbuilder is specified)</li>
</ul>
</blockquote>
<p>VERSION = 0.5.0</p>
<blockquote>
<ul class="simple">
<li>mothermapper debugged</li>
<li>_insertNoOid() debugged when pkey is absent</li>
<li>inline docs more complete</li>
<li>lambdas removed</li>
</ul>
</blockquote>
<p>VERSION = 0.4.9</p>
<blockquote>
<ul class="simple">
<li>from mother.speaker import * not needed on the conf file</li>
<li>added a tester script</li>
<li>a lot of global vars removed</li>
<li>joining accepts new argument: jfilter!</li>
<li>all database actions converted to new OIDs conf</li>
<li>DbMother._sqlPkeysFromOid added</li>
<li>DbMother._sqlWhereOid dropped</li>
<li>MotherBox is not using OIDs anymore</li>
<li>init_mother test MOTHER_OIDS and does what has to be done</li>
<li>Mother conf file accepts keyword MOTHER_OIDS</li>
<li>Mother is preparing to drop completely OIDs</li>
<li>The MotherBox accepts now the new arg notriggers (defaults True)</li>
<li>oid is removed almost everywhere: it remains in _insert()</li>
</ul>
</blockquote>
<p>VERSION = 0.4.8-r2</p>
<blockquote>
<ul class="simple">
<li>a few bugs</li>
</ul>
</blockquote>
<p>VERSION = 0.4.8-r1</p>
<blockquote>
<ul class="simple">
<li>DbMother.update() bug fixed.</li>
<li>On install, check if psycopg2 is installed. If not, print a warning.</li>
</ul>
</blockquote>
<p>VERSION = 0.4.8</p>
<blockquote>
<ul class="simple">
<li>DbMother.update takes now an argument</li>
<li>MotherCaster accepts required_fields</li>
<li>filters fixed</li>
<li>inline docs are now fine</li>
<li>updateChildren had a bug due to the last updates</li>
<li>New Plugin Mothercaster</li>
<li>New submodule mother.plugins</li>
<li>Mother RAM Optimizations: _trigger_actions and _flag_actions are
now staticmethod</li>
</ul>
</blockquote>
<p>VERSION = 0.4.7</p>
<blockquote>
<ul class="simple">
<li>SQL optimizations: oid loading is now not needed everywhere
Note that queries will be executed with less controls, but more faster.</li>
<li>SQL optimizations: MotherBox don't need to SELECT from DB to fire triggers</li>
<li>SQL optimizations: sql string methods are now faster and cleaner</li>
<li>Pretty Print: debug messages more friendly</li>
<li>Some debug on dbda.py</li>
<li>SQL_DEFAULT is always applied</li>
<li>Memory Optimizations: Multiple Variables inside functions</li>
<li>Color Wrappers OKI_COL, ERR_COL, INF_COL</li>
<li>MotherBox from scratch: unneeded methods removed and optimizations</li>
<li>DbMother controls fields</li>
</ul>
</blockquote>
<p>VERSION = 0.4.6</p>
<blockquote>
<ul class="simple">
<li>mothermapper has the new option '-v'</li>
<li>conf files and maps are loaded with execfile: import avoided</li>
<li>INSTALL</li>
<li>mothermapper accepts new options: Q, S, C. Obsolete options: r</li>
<li>multiple global variables removed from speaker</li>
<li>setup.py has been created: Mother become a standard python module!!</li>
<li>the map file could be created everywhere: init_mother(), init_dbda()
and init_speaker depend now on the location of this file.</li>
<li>dbstruct.py and rels.py are merged in a unique file: the map file</li>
<li>dbmapper.py is moved on mothermapper and it's installed as system script</li>
<li>new documentation: mother_threads.txt</li>
<li>metaqry.py merged in dbmapper.py</li>
<li>Mothers classes store sessions</li>
<li>conf.py is now almost commented: default values defined</li>
<li>Sessions naming</li>
<li>New API MotherSession()</li>
<li>Initialization methods don't use globals() (more safe)</li>
<li>New Class PsygresPool to use a pool of persistent connections</li>
<li>New Class PsygresFly to use isolated DB Sessions</li>
</ul>
</blockquote>
<p>VERSION = 0.4.5</p>
<blockquote>
<ul class="simple">
<li>new svn layout</li>
<li>Added support for log file rotation</li>
<li>mothers should be Win32 compatible</li>
<li>speaker supports now: log_to_file, log_to_syslog, log_to_stdout, log_to_smtp</li>
<li>box.py removed: MotherBox is merged on mothers.py</li>
<li>dbda.py and speaker.py from scratch using Classes and staticmethods</li>
<li>supersingleton pattern removed</li>
<li>init_methods() introduced</li>
<li>shared.py removed</li>
<li>headers files removed (speaker_h.py, mothers_h.py)</li>
<li>speaker uses now the logging module instead of syslog: API is changed!!!</li>
</ul>
</blockquote>
<p>VERSION = 0.4.4-r1</p>
<blockquote>
<ul class="simple">
<li>mothers.py cleaned from old unused variables</li>
<li>mother_init works at the same time with ZpsycoPGDA and psycopg2</li>
<li>MotherBox debugged: store -&gt; _store</li>
<li>MotherFly accepts now the argument oid</li>
</ul>
</blockquote>
<p>VERSION = 0.4.4</p>
<blockquote>
<ul class="simple">
<li>MotherBox debugged: select oid -&gt; select tbl.oid</li>
<li>dbmapper uses now DEFAULT_LOGGER</li>
<li>pop inserted on MotherBox.getFields</li>
<li>MotherBox.getFields and MotherBox.filterBox optimized</li>
<li>Database adapter is implemented with SuperSingleton design pattern</li>
<li>Introduced test.py: example and test module</li>
</ul>
</blockquote>
<p>VERSION = 0.4.3</p>
<blockquote>
<ul class="simple">
<li>triggers debugged. The bug was heavy, so the new release.</li>
</ul>
</blockquote>
<p>VERSION = 0.4.2</p>
<blockquote>
<ul class="simple">
<li>debugged mothers.py:805</li>
<li>MotherBox._sqlBuildFilterBox: controls when WHERE is present in the filter.</li>
<li>MotherManager.deleteChildren: no more using getChildren</li>
<li>debug on MotherBox</li>
<li>Speaker.log_int_raise was printing 2 times the error string</li>
<li>_sqlJoinParent debugged</li>
</ul>
</blockquote>
<p>VERSION &lt; 0.4.2</p>
<blockquote>
<ul class="simple">
<li>First official release</li>
</ul>
</blockquote>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
